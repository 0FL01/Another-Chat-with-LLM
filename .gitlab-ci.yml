variables:
  DOCKER_IMAGE: 0fl01/another-chat-tg
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TLS_VERIFY: ""
  DOCKER_DRIVER: overlay2

stages:
  - test
  - build
  - deploy

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event' && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == 'main'
    - if: $CI_COMMIT_BRANCH == 'testing' && $CI_PIPELINE_SOURCE == 'push'
    - if: $CI_COMMIT_TAG =~ /^v.*/ && $CI_PIPELINE_SOURCE == 'push'

test:
  stage: test
  image: python:3.10-slim
  variables:
    ADMIN_ID: $ADMIN_ID
  script:
    - python -m pip install --upgrade pip
    - pip install "pytest>=7.0.0" "pytest-asyncio>=0.18.0" "pytest-mock>=3.7.0" "psycopg2-binary>=2.9.10"
    - |
      if [ -f requirements.txt ]; then
        pip install -r requirements.txt
      fi
    - python -m pytest tests/ --maxfail=1 --disable-warnings
  rules:
    - when: always

build:
  stage: build
  image: docker:25.0
  services:
    - docker:25.0-dind
  needs: [test]
  variables:
    GIT_STRATEGY: clone
    GIT_CHECKOUT: "true"
  before_script:
    - until docker info; do sleep 1; done # ждём запуска Docker-in-Docker
    - echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
  script:
    - export SHA_SHORT=$CI_COMMIT_SHORT_SHA
    - echo "Building image: ${DOCKER_IMAGE}:${SHA_SHORT}"
    - docker build --pull --label "org.opencontainers.image.source=${CI_REPOSITORY_URL}" --label "org.opencontainers.image.revision=${CI_COMMIT_SHA}" -t "${DOCKER_IMAGE}:${SHA_SHORT}" .
    - |
      if [ "$CI_PIPELINE_SOURCE" != "merge_request_event" ]; then
        echo "Pushing image: ${DOCKER_IMAGE}:${SHA_SHORT}"
        docker push "${DOCKER_IMAGE}:${SHA_SHORT}"
      else
        echo "Skipping push for merge request."
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == 'push' && $CI_COMMIT_BRANCH == 'testing'
    - if: $CI_PIPELINE_SOURCE == 'push' && $CI_COMMIT_TAG =~ /^v.*/

deploy:
  stage: deploy
  image: alpine:latest
  needs: [build]
  environment:
    name: dev
  before_script:
    - apk add --no-cache openssh-client docker-compose
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -p "$SSH_PORT" "$SSH_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - export SHA_SHORT=$CI_COMMIT_SHORT_SHA
    - |
      ssh -p "$SSH_PORT" "$SSH_USERNAME@$SSH_HOST" "
        set -e
        if [ -z \"${SHA_SHORT}\" ]; then echo 'Error: SHA_SHORT is empty'; exit 1; fi
        mkdir -p ${SERVICE_DIR} && cd ${SERVICE_DIR}
        cat << 'EOF_ENV' > .env
  GROQ_API_KEY=${GROQ_API_KEY}
  TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
  MISTRAL_API_KEY=${MISTRAL_API_KEY}
  GEMINI_API_KEY=${GEMINI_API_KEY}
  ADMIN_ID=${ADMIN_ID}
  SYSTEM_MESSAGE=${SYSTEM_MESSAGE}
  POSTGRES_DB=${POSTGRES_DB}
  POSTGRES_USER=${POSTGRES_USER}
  POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
  POSTGRES_HOST=${POSTGRES_HOST}
  POSTGRES_PORT=${POSTGRES_PORT}
EOF_ENV
        cat << EOF_COMPOSE > docker-compose.yml
services:
  another_chat_tg:
    image: ${DOCKER_IMAGE}:${SHA_SHORT}
    container_name: another_chat_tg
    network_mode: \"host\"
    environment:
      - POSTGRES_HOST=127.0.0.1
    restart: unless-stopped
    volumes:
      - ./.env:/app/.env:ro
EOF_COMPOSE
        docker compose pull
        docker compose down || true
        docker compose up -d
        docker compose ps
        docker images --format \"{{.Repository}}:{{.Tag}} {{.ID}}\" | grep \"^${DOCKER_IMAGE}\" | grep -v \":${SHA_SHORT}\" | awk '{ print \$2 }' | xargs -r docker rmi -f || true
      "
  rules:
    - if: $CI_PIPELINE_SOURCE == 'push' && $CI_COMMIT_BRANCH == 'testing'
    - if: $CI_PIPELINE_SOURCE == 'push' && $CI_COMMIT_TAG =~ /^v.*/